@page "/"
@inject IJSRuntime JS
@inject ILoggerFactory LoggerFactory
@implements IAsyncDisposable
@using System.Text
@using Centrifugal.Centrifuge

<PageTitle>Centrifuge Blazor Example</PageTitle>

<div class="container">
    <h1>Centrifuge C# SDK - Blazor WebAssembly Example!</h1>

    <p>This example demonstrates the Centrifuge SDK in Blazor WebAssembly.</p>

    @if (_client == null)
    {
        <div class="transport-selector">
            <h3>Select Transport</h3>
            <p class="transport-hint">Your selection will be saved for next time</p>
            <div class="transport-buttons">
                <button class="transport-btn websocket" @onclick="() => ConnectWithTransport(false)">
                    <span class="transport-icon">ðŸ”Œ</span>
                    <span class="transport-name">WebSocket</span>
                    <span class="transport-desc">Browser-native WebSocket (recommended)</span>
                </button>
                <button class="transport-btn httpstream" @onclick="() => ConnectWithTransport(true)">
                    <span class="transport-icon">ðŸ“¡</span>
                    <span class="transport-name">HTTP Streaming</span>
                    <span class="transport-desc">HTTP with Server-Sent Events emulation</span>
                </button>
            </div>
        </div>
    }
    else
    {
        <div class="transport-info">
            <span class="transport-label">Transport:</span>
            <span class="transport-value">@(_useHttpStreaming ? "HTTP Streaming" : "WebSocket")</span>
            <button class="reconnect-btn" @onclick="Reconnect">Switch Transport</button>
        </div>
    }

    <div class="status-bar">
        <div class="status-item">
            <span class="status-label">Client:</span>
            <span class="status-value @GetStateClass(_clientState)">@_clientState</span>
        </div>
        <div class="status-item">
            <span class="status-label">Subscription:</span>
            <span class="status-value @GetStateClass(_subscriptionState)">@_subscriptionState</span>
        </div>
        @if (!string.IsNullOrEmpty(_lastMessage))
        {
            <div class="status-item">
                <span class="status-label">Last Message:</span>
                <span class="status-value">@_lastMessage</span>
            </div>
        }
    </div>

    <div class="events-container">
        <div class="events-header">
            <h3>Events Log</h3>
            <button class="clear-btn" @onclick="ClearEvents">Clear</button>
        </div>
        <div class="events-list">
            @foreach (var msg in _events.AsEnumerable().Reverse())
            {
                <div class="event-item @GetEventClass(msg)">
                    @msg
                </div>
            }
            @if (_events.Count == 0)
            {
                <div class="event-item empty">No events yet.</div>
            }
        </div>
    </div>
</div>

<style>
    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    h1 {
        color: #2c3e50;
        margin-bottom: 1rem;
    }

    .status-bar {
        display: flex;
        gap: 2rem;
        flex-wrap: wrap;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1.5rem;
        border-radius: 8px;
        margin: 2rem 0;
        color: white;
    }

    .status-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .status-label {
        font-weight: 600;
        opacity: 0.9;
    }

    .status-value {
        background: rgba(255, 255, 255, 0.2);
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-weight: 700;
        text-transform: uppercase;
        font-size: 0.85rem;
    }

    .status-value.connected {
        background: #10b981;
    }

    .status-value.subscribed {
        background: #10b981;
    }

    .status-value.connecting,
    .status-value.subscribing {
        background: #f59e0b;
    }

    .status-value.disconnected,
    .status-value.unsubscribed {
        background: #ef4444;
    }

    .events-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }

    .events-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        background: #f8f9fa;
        border-bottom: 2px solid #e9ecef;
    }

    .events-header h3 {
        margin: 0;
        color: #2c3e50;
    }

    .clear-btn {
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background 0.2s;
    }

    .clear-btn:hover {
        background: #5a6268;
    }

    .events-list {
        max-height: 600px;
        overflow-y: auto;
        padding: 1rem;
    }

    .event-item {
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        border-left: 4px solid #0078d4;
        background: #f8f9fa;
        transition: all 0.2s;
    }

    .event-item:hover {
        background: #e9ecef;
        transform: translateX(2px);
    }

    .event-item.client {
        border-left-color: #0078d4;
        background: #e3f2fd;
    }

    .event-item.subscription {
        border-left-color: #00bcd4;
        background: #e0f7fa;
    }

    .event-item.error {
        border-left-color: #f44336;
        background: #ffebee;
    }

    .event-item.success {
        border-left-color: #4caf50;
        background: #e8f5e9;
    }

    .event-item.info {
        border-left-color: #ff9800;
        background: #fff3e0;
    }

    .event-item.empty {
        border-left-color: #9e9e9e;
        background: #fafafa;
        text-align: center;
        font-style: italic;
        color: #757575;
    }

    .transport-selector {
        background: white;
        border-radius: 8px;
        padding: 2rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        margin: 2rem 0;
    }

    .transport-selector h3 {
        margin: 0 0 0.5rem 0;
        color: #2c3e50;
        text-align: center;
    }

    .transport-hint {
        margin: 0 0 1.5rem 0;
        color: #6c757d;
        text-align: center;
        font-size: 0.875rem;
        font-style: italic;
    }

    .transport-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
    }

    .transport-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 2rem 1.5rem;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        transition: all 0.3s;
        font-family: inherit;
    }

    .transport-btn:hover {
        border-color: #667eea;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
    }

    .transport-btn.websocket:hover {
        background: linear-gradient(135deg, #667eea22 0%, #764ba222 100%);
    }

    .transport-btn.httpstream:hover {
        background: linear-gradient(135deg, #f093fb22 0%, #f5576c22 100%);
    }

    .transport-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
    }

    .transport-name {
        font-size: 1.25rem;
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 0.5rem;
    }

    .transport-desc {
        font-size: 0.875rem;
        color: #6c757d;
        text-align: center;
    }

    .transport-info {
        display: flex;
        align-items: center;
        gap: 1rem;
        background: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        margin: 2rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .transport-label {
        font-weight: 600;
        color: #6c757d;
    }

    .transport-value {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-weight: 600;
    }

    .reconnect-btn {
        margin-left: auto;
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background 0.2s;
    }

    .reconnect-btn:hover {
        background: #5a6268;
    }

    @@media (max-width: 768px) {
        .container {
            padding: 1rem;
        }

        .status-bar {
            flex-direction: column;
            gap: 1rem;
        }

        .events-list {
            max-height: 400px;
        }
    }
</style>

@code {
    private CentrifugeClient? _client;
    private CentrifugeSubscription? _subscription;
    private string _clientState = "Not Connected";
    private string _subscriptionState = "Not Created";
    private string _lastMessage = "";
    private List<string> _events = new List<string>();
    private bool _useHttpStreaming;
    private const string TransportStorageKey = "centrifuge-transport-preference";

    protected override async Task OnInitializedAsync()
    {
        // Try to load saved transport preference
        try
        {
            var savedTransport = await JS.InvokeAsync<string?>("localStorage.getItem", TransportStorageKey);
            if (!string.IsNullOrEmpty(savedTransport))
            {
                var useHttpStreaming = savedTransport == "httpstream";
                await LogAsync($"Found saved transport preference: {savedTransport}");
                await ConnectWithTransport(useHttpStreaming);
            }
        }
        catch (Exception ex)
        {
            await LogAsync($"Could not load saved transport preference: {ex.Message}");
        }
    }

    private async Task ConnectWithTransport(bool useHttpStreaming)
    {
        _useHttpStreaming = useHttpStreaming;

        // Save transport preference to local storage
        try
        {
            var transportName = useHttpStreaming ? "httpstream" : "websocket";
            await JS.InvokeVoidAsync("localStorage.setItem", TransportStorageKey, transportName);
        }
        catch (Exception ex)
        {
            await LogAsync($"Could not save transport preference: {ex.Message}");
        }

        var logger = LoggerFactory.CreateLogger<CentrifugeClient>();

        if (useHttpStreaming)
        {
            _client = new CentrifugeClient(
                new[]
                {
                    new CentrifugeTransportEndpoint(
                        CentrifugeTransportType.HttpStream,
                        "http://localhost:8000/connection/http_stream"
                    )
                },
                options: new CentrifugeClientOptions
                {
                    Logger = logger
                }
            );
        }
        else
        {
            _client = new CentrifugeClient(
                "ws://localhost:8000/connection/websocket",
                options: new CentrifugeClientOptions
                {
                    Logger = logger
                }
            );
        }

        await LogAsync("Centrifuge C# SDK - Blazor WASM Example");
        await LogAsync("=========================================");
        await LogAsync($"Using transport: {(useHttpStreaming ? "HTTP Streaming" : "WebSocket")}");

        // Setup client event handlers
        _client.StateChanged += OnStateChanged;
        _client.Connecting += OnConnecting;
        _client.Connected += OnConnected;
        _client.Disconnected += OnDisconnected;
        _client.Error += OnError;

        try
        {
            // Connect to server (non-blocking)
            await LogAsync("Connecting to server...");
            _client.Connect();

            // Create subscription
            _subscription = _client.NewSubscription("chat");

            // Setup subscription event handlers
            _subscription.StateChanged += OnSubscriptionStateChanged;
            _subscription.Subscribing += OnSubscribing;
            _subscription.Subscribed += OnSubscribed;
            _subscription.Unsubscribed += OnUnsubscribed;
            _subscription.Publication += OnPublication;
            _subscription.Join += OnJoin;
            _subscription.Leave += OnLeave;
            _subscription.Error += OnSubscriptionError;

            // Subscribe to channel (non-blocking)
            await LogAsync("Subscribing to channel 'chat'...");
            _subscription.Subscribe();

            // Wait for subscription to complete
            try
            {
                await _subscription.ReadyAsync();
                await LogAsync("Subscription ready!");
            }
            catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
            {
                await LogAsync($"Subscription timed out: {ex.Message}");
                return;
            }
            catch (Exception ex)
            {
                await LogAsync($"Subscription failed: {ex.Message}");
                return;
            }

            // === BATCHING DEMONSTRATION ===
            // Issue multiple API calls WITHOUT awaiting them immediately.
            // They will be automatically batched together (1ms window by default).
            await LogAsync("");
            await LogAsync("=== DEMONSTRATING COMMAND BATCHING ===");
            await LogAsync("Issuing multiple commands without awaiting...");

            var messageData = Encoding.UTF8.GetBytes("{\"text\":\"Hello from Blazor WASM!\"}");

            // Start all operations concurrently - they will be batched!
            var publishTask = _subscription.PublishAsync(messageData);
            var presenceTask = _subscription.PresenceAsync();
            var presenceStatsTask = _subscription.PresenceStatsAsync();
            var historyTask = _subscription.HistoryAsync(new CentrifugeHistoryOptions
            {
                Limit = 10,
                Reverse = true
            });
            var rpcTask = _client.RpcAsync("time", Encoding.UTF8.GetBytes("{\"method\":\"getCurrentTime\"}"));

            await LogAsync("All commands queued! They will be sent in a single batch.");
            await LogAsync($"Transport: {(_useHttpStreaming ? "HTTP Stream (TRUE batching - one POST)" : "WebSocket (pipelined)")}");
            await LogAsync("Waiting for all responses...");

            try
            {
                await LogAsync("");
                await LogAsync("=== BATCH RESULTS ===");

                // Process publish result
                try
                {
                    await publishTask;
                    await LogAsync("âœ“ Publish succeeded");
                }
                catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
                {
                    await LogAsync($"âœ— Publish timed out: {ex.Message}");
                }
                catch (Exception ex)
                {
                    await LogAsync($"âœ— Publish failed: {ex.Message}");
                }

                // Process presence result
                try
                {
                    var presence = await presenceTask;
                    await LogAsync($"âœ“ Presence: {presence.Clients.Count} clients");
                    foreach (var (clientId, clientInfo) in presence.Clients)
                    {
                        await LogAsync($"    - {clientId}: user={clientInfo.User}");
                    }
                }
                catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
                {
                    await LogAsync($"âœ— Presence timed out: {ex.Message}");
                }
                catch (Exception ex)
                {
                    await LogAsync($"âœ— Presence failed: {ex.Message}");
                }

                // Process presence stats result
                try
                {
                    var stats = await presenceStatsTask;
                    await LogAsync($"âœ“ Presence stats: {stats.NumClients} clients, {stats.NumUsers} users");
                }
                catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
                {
                    await LogAsync($"âœ— Presence stats timed out: {ex.Message}");
                }
                catch (Exception ex)
                {
                    await LogAsync($"âœ— Presence stats failed: {ex.Message}");
                }

                // Process history result
                try
                {
                    var history = await historyTask;
                    await LogAsync($"âœ“ History: {history.Publications.Length} messages");
                    foreach (var pub in history.Publications.Take(3))
                    {
                        var data = Encoding.UTF8.GetString(pub.Data.Span);
                        await LogAsync($"    - {data}");
                    }
                    if (history.Publications.Length > 3)
                    {
                        await LogAsync($"    ... and {history.Publications.Length - 3} more");
                    }
                }
                catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
                {
                    await LogAsync($"âœ— History timed out: {ex.Message}");
                }
                catch (Exception ex)
                {
                    await LogAsync($"âœ— History failed: {ex.Message}");
                }

                // Process RPC result
                try
                {
                    var rpcResult = await rpcTask;
                    var response = Encoding.UTF8.GetString(rpcResult.Data.Span);
                    await LogAsync($"âœ“ RPC response: {response}");
                }
                catch (CentrifugeException ex) when (ex.Code == CentrifugeErrorCodes.Timeout)
                {
                    await LogAsync($"âœ— RPC timed out: {ex.Message}");
                }
                catch (Exception ex)
                {
                    await LogAsync($"âœ— RPC failed: {ex.Message}");
                }

                await LogAsync("");
                await LogAsync($"All 5 commands were batched and sent together!");
                await LogAsync($"Benefits: {(_useHttpStreaming ? "Reduced from 5 HTTP requests to 1!" : "Sent in quick succession via pipelining")}");
            }
            catch (Exception ex)
            {
                await LogAsync($"Unexpected error: {ex.Message}");
            }

            await LogAsync("Example completed! The connection will remain open for incoming messages.");
        }
        catch (Exception ex)
        {
            await LogAsync($"Error: {ex.Message}");
            await LogAsync($"Stack trace: {ex.StackTrace}");
        }
    }

    private void OnStateChanged(object? sender, CentrifugeStateEventArgs e)
    {
        _clientState = e.NewState.ToString();
        _ = LogAsync($"[Client] State: {e.OldState} -> {e.NewState}");
    }

    private void OnConnecting(object? sender, CentrifugeConnectingEventArgs e)
    {
        _ = LogAsync($"[Client] Connecting: {e.Code} - {e.Reason}");
    }

    private void OnConnected(object? sender, CentrifugeConnectedEventArgs e)
    {
        _ = LogAsync($"[Client] Connected!");
        _ = LogAsync($"  Client ID: {e.ClientId}");
        _ = LogAsync($"  Transport: {e.Transport}");
    }

    private void OnDisconnected(object? sender, CentrifugeDisconnectedEventArgs e)
    {
        _ = LogAsync($"[Client] Disconnected: {e.Code} - {e.Reason}");
    }

    private void OnError(object? sender, CentrifugeErrorEventArgs e)
    {
        _ = LogAsync($"[Client] Error: {e.Type} - {e.Message}");
    }

    private void OnSubscriptionStateChanged(object? sender, CentrifugeSubscriptionStateEventArgs e)
    {
        _subscriptionState = e.NewState.ToString();
        _ = LogAsync($"[Subscription] State: {e.OldState} -> {e.NewState}");
    }

    private void OnSubscribing(object? sender, CentrifugeSubscribingEventArgs e)
    {
        _ = LogAsync($"[Subscription] Subscribing: {e.Code} - {e.Reason}");
    }

    private void OnSubscribed(object? sender, CentrifugeSubscribedEventArgs e)
    {
        _ = LogAsync($"[Subscription] Subscribed!");
        if (e.WasRecovering)
        {
            _ = LogAsync($"  Recovery attempted, recovered: {e.Recovered}");
        }
    }

    private void OnUnsubscribed(object? sender, CentrifugeUnsubscribedEventArgs e)
    {
        _ = LogAsync($"[Subscription] Unsubscribed: {e.Code} - {e.Reason}");
    }

    private void OnPublication(object? sender, CentrifugePublicationEventArgs e)
    {
        var data = Encoding.UTF8.GetString(e.Data.Span);
        _lastMessage = data;
        _ = LogAsync($"[Subscription] Publication received:");
        _ = LogAsync($"  Channel: {e.Channel}");
        _ = LogAsync($"  Data: {data}");
        if (e.Offset.HasValue)
        {
            _ = LogAsync($"  Offset: {e.Offset}");
        }
        if (e.Info != null)
        {
            _ = LogAsync($"  From: {e.Info.Value.Client} (user: {e.Info.Value.User})");
        }
    }

    private void OnJoin(object? sender, CentrifugeJoinEventArgs e)
    {
        _ = LogAsync($"[Subscription] Client joined: {e.Info.Client}");
    }

    private void OnLeave(object? sender, CentrifugeLeaveEventArgs e)
    {
        _ = LogAsync($"[Subscription] Client left: {e.Info.Client}");
    }

    private void OnSubscriptionError(object? sender, CentrifugeErrorEventArgs e)
    {
        _ = LogAsync($"[Subscription] Error: {e.Type} - {e.Message}");
    }

    private async Task LogAsync(string message)
    {
        // Optionally log to browser console for debugging (uncomment if needed)
        // await JS.InvokeVoidAsync("console.log", message);

        // Add to events list for UI
        _events.Add($"[{DateTime.Now:HH:mm:ss}] {message}");
        if (_events.Count > 200)
        {
            _events.RemoveAt(0);
        }

        // Update UI
        await InvokeAsync(StateHasChanged);
    }

    private void ClearEvents()
    {
        _events.Clear();
        StateHasChanged();
    }

    private string GetStateClass(string state)
    {
        return state.ToLower();
    }

    private string GetEventClass(string message)
    {
        if (message.Contains("[Client]"))
            return "client";
        if (message.Contains("[Subscription]"))
            return "subscription";
        if (message.Contains("Error") || message.Contains("failed") || message.Contains("not available"))
            return "error";
        if (message.Contains("Connected") || message.Contains("Subscribed") || message.Contains("Publishing"))
            return "success";
        if (message.Contains("Fetching") || message.Contains("Presence") || message.Contains("History") || message.Contains("RPC"))
            return "info";
        return "";
    }

    private async Task Reconnect()
    {
        await LogAsync("Reconnecting with different transport...");

        // Cleanup current connection
        if (_subscription != null)
        {
            _subscription.Unsubscribe();
            _subscription = null;
        }

        if (_client != null)
        {
            await _client.DisposeAsync();
            _client = null;
        }

        _events.Clear();
        _clientState = "Not Connected";
        _subscriptionState = "Not Created";
        _lastMessage = "";

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await LogAsync("Disposing...");

            if (_subscription != null)
            {
                await LogAsync("Unsubscribing...");
                _subscription.Unsubscribe();
            }

            await LogAsync("Disposing client (this will disconnect)...");
            if (_client != null)
            {
                await _client.DisposeAsync();
            }

            await LogAsync("Done!");
        }
        catch (Exception ex)
        {
            await LogAsync($"Error during disposal: {ex.Message}");
        }
    }
}
